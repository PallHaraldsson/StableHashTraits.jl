var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"stable_hash\nHashVersion\nstable_type_name\nStableHashTraits.transformer\nStableHashTraits.Transformer\nStableHashTraits.TransformIdentity\nStableHashTraits.preserves_structure\nStableHashTraits.CachedHash\nStableHashTraits.UseCache\nStableHashTraits.type_hash_name\nStableHashTraits.type_value_name\nStableHashTraits.type_structure\nStableHashTraits.is_ordered\nStableHashTraits.hash_sort_by\nStableHashTraits.parent_context\nStableHashTraits.root_version\nTablesEq\nViewsEq\nWithTypeNames","category":"page"},{"location":"api/#StableHashTraits.stable_hash","page":"API","title":"StableHashTraits.stable_hash","text":"stable_hash(x, context=HashVersion{1}(); alg=sha256)\nstable_hash(x; alg=sha256, version=1)\n\nCreate a stable hash of the given objects. As long as the context remains the same, this hash is intended to remain unchanged across julia versions. The built-in context is HashVersion{N}, and if you specify a version, this is equivalent to explicitly passing HashVersion{version}. To customize how the hash is copmuted see Using Contexts.\n\nIt is best to pass an explicit version, since HashVersion{3} is the only non-deprecated version; it is much faster than 1 and more stable than 2. Furthermore, a new hash version is provided in a future release, the hash you get by passing an explicit HashVersion{N} should not change. (Note that the number in HashVersion does not necessarily match the package version of StableHashTraits).\n\nIn hash version 3, you customize how hashes are computed using transformer, and in versions 1-2 using hash_method.\n\nTo change the hash algorithm used, pass a different function to alg. It accepts any sha related function from SHA or any function of the form hash(x::AbstractArray{UInt8}, [old_hash]).\n\nThe context value gets passed as the second argument to hash_method and [transformer], and as the third argument to StableHashTraits.write. Note that both hash_method and StableHashTraits.write are deprecated.\n\nSee Also\n\ntransformer\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.HashVersion","page":"API","title":"StableHashTraits.HashVersion","text":"HashVersion{V}()\n\nThe default hash_context used by stable_hash. There are currently three versions (1-3). Version 3 should be favored when at all possible. Version 1 is the default version, so as to avoid changing the hash computed by existing code.\n\nBy explicitly passing this hash version in stable_hash you ensure that hash values for these fallback methods will not change even if new hash versions are developed.\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.stable_type_name","page":"API","title":"StableHashTraits.stable_type_name","text":"stable_type_name(::Type{T})\nstable_type_name(T::Module)\nstable_type_name(::T) where {T}\n\nGet a stable name of T. The stable name includes the name of the module that T was defined in. Any uses of Core are replaced with Base to keep the name stable across versions of julia. Anonymous names (e.g. stable_type_name(x -> x+1)) throw an error, as no stable name is possible in this case.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.transformer","page":"API","title":"StableHashTraits.transformer","text":"StableHashTraits.transformer(::Type{T}, [context]) where {T}\n\nReturn Transformer indicating how to modify an object of type T before hashing it. Methods without a context are called if no method for that type exists for any specific context object.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.Transformer","page":"API","title":"StableHashTraits.Transformer","text":"StableHashTraits.Transformer(fn=identity, result_method=nothing;\n                             preserves_structure=StableHashTraits.preserves_structure(fn))\n\nWraps the function used to transform values before they are hashed. The function is applied (fn(x)), and then its result is hashed according to the trait @something result_method StructType(fn(x)).\n\nThe flag preserves_structure indicates if it is safe to hoist type hashes outside of loops; this is always the case when fn is type stable. See the manual for details about other cases when it is safe to set this flag to true.\n\nSee Also\n\ntransformer\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.TransformIdentity","page":"API","title":"StableHashTraits.TransformIdentity","text":"StableHashTraits.TransformIdentity(x)\n\nSignal that the type x should not be transformed in the usual way, but by hashing x directly. This is useful when you want to hash both x the way it would normally be hashed without a specialized method of transformer along with some metadata. Without this wrapper, returning (metadata(x), x) from the transforming function would cause an infinite regress (adding metadata(x) upon each call).\n\nExample\n\nstruct MyArray <: AbstractVector{Int}\n    data::Vector{Int}\n    meta::Dict{String, String}\nend\n# other array methods go here...\nfunction StableHashTraits.transformer(::Type{<:MyArray})\n    return Transformer(x -> (x.meta, TransformIdentity(x)); preserves_structure=true)\nend\n\nIn this example we hash both some metadata about a custom array, and each of the elements of x\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.preserves_structure","page":"API","title":"StableHashTraits.preserves_structure","text":"StableHashTraits.preserves_structure(fn)\n\nReturns true if it is known that fn preservess structure ala Transformer. This is false by default for all functions but identity. You can define a method of this function for your own fn's to signal that they their results can be safely optimized via hoisting the type hash outside of loops during hashing.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.CachedHash","page":"API","title":"StableHashTraits.CachedHash","text":"CachedHash(context)\n\nSetup a hash context that includes a cache of hash results. By default, it stores the result of hashing types and large values. Calling the same cached hash context will re-use this cache, possibly improving performance. If you do not pass a CachedHash to stable_hash it sets up its own internal cache to improve performance for repeated hashes of the same type or large values seen within the call to stable_hash.\n\nFor an object to be cached you must either signal that it should be, using UseCache or it must be:\n\nlarge enough: this is to ensure that calls to retrieve a cached result do not exceed the time it takes to simply re-hash the individual bytes of an object. You can refer to the constant CACHE_OBJECT_THRESHOLD though it is not considered part of the public API and may change with future hash versions. (The threshold will not change for a given hash version, since changing it can change an object's hashed value).\nmutable: immutable objects cannot be stored in a WeakKeyIdDict, since they aren't supported. This means that caching immutable objects can lead to memory leaks if you don't clean up the cache regularly, since they are stored in an IdDict. Note that in practice large amounts of data are usually stored in mutable structures like Array and String.\n\nSee Also\n\nstable_hash\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.UseCache","page":"API","title":"StableHashTraits.UseCache","text":"StableHashTraits.UseCache(x)\n\nSignal that the hash of x should be stored in the cache.\n\nwarning: Immutable objects can leak memory\nIf x is immutable, caching it will cause the object x to be held in memory until the cache is garbage collected. WeakKeyIdDicts do not support immutable objects. If there is no user defined cache, the cache will be garbage collected inside the call to stable_hash. With a user defined hash you will need to make sure your cache goes out of scope in a timely fashion to avoid memory leaks.\n\nSee Also\n\ntransformer\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.type_hash_name","page":"API","title":"StableHashTraits.type_hash_name","text":"type_hash_name(::Type{T}, trait, [context])\n\nThe name that is hashed for type T when hashing the type of a given value. This defaults to stable_type_name(trait). Users of StableHashTraits can implement a method that accepts two (T and trait) or three arguments (T, trait, context). The trait is one of the StructTypes traits and context is the hash context (as per the second argument to stable_hash)\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.type_value_name","page":"API","title":"StableHashTraits.type_value_name","text":"type_value_name(::Type{T}, trait, [context]) where {T}\n\nThe name that is hashed for type T when hashing a type as a value (e.g. stable_hash(Int)). This defaults to stable_type_name(T). Users of StableHashTraits can implement a method that accepts two (T and trait) or three arguments (T, trait, context). The trait is one of the StructTypes traits and context is the hash context (as per the second argument to stable_hash)\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.type_structure","page":"API","title":"StableHashTraits.type_structure","text":"type_structure(::Type{T}, trait, [context])\n\nGet the types and symbols that represent the structure of T. The trait is the StructType of T and context is the hash context (as per the second argument to stable_hash). The second argument must be included as part of a method definition, but context is optional.\n\nYou need to override this method when a type parameter of T is important to the type's hash but is not included as part of the normal hash.\n\nThe normal hash includes:\n\nfieldtypes(T) of any StructType.DataType (e.g. StructType.Struct)\neltype(T) of any StructType.ArrayType or StructType.DictType\nndims(T) of any AbstractArray that is a StructType.ArrayTYpe and that has a concrete dimension\n\nExample\n\nstruct MyType{T,F}\n    obj::T\nend\nStableHashTratis.type_structure(::Type{T}, ::StructTypes.DataType) where {F,T<:MyType{<:Any,F}}\n    return fieldnames(T), fieldtypes(T), F\nend\n\nWithout this definition MyType{Int,:foo}(1) would hash to the same value as MyType{Int,:bar}(1).\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.is_ordered","page":"API","title":"StableHashTraits.is_ordered","text":"is_ordered(x)\n\nIndicates whether the order of the elements of object x are important to its hashed value. If false, x's elements will first be collected and sort'ed before hashing them. When calling sort, hash_sort_by is passed as the by keyword argument. If x is a DictType, the elements are sorted by their keys rather than their elements.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.hash_sort_by","page":"API","title":"StableHashTraits.hash_sort_by","text":"`hash_sort_by(x)`\n\nDefines how the elements of a hashed container x are sorted if is_ordered of x returns false. The return value of this function is passed to sort as the by keyword.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.parent_context","page":"API","title":"StableHashTraits.parent_context","text":"StableHashTraits.parent_context(context)\n\nReturn the parent context of the given context object. (See hash_method for details of using context). The default method falls back to returning HashVersion{1}, but this is flagged as a deprecation warning; in the future it is expected that all contexts define this method.\n\nThis is normally all that you need to know to implement a new context. However, if your context is expected to be the root context—one that does not fallback to any parent (akin to HashVersion)—then there may be a bit more work involved. In this case, parent_context should return nothing. You will also need to define StableHashTraits.root_version.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.root_version","page":"API","title":"StableHashTraits.root_version","text":"StableHashTraits.root_version(context)\n\nReturn the version of the root context: an integer in the range (1, 2). The default fallback method value returns 1.\n\nIn almost all cases, a root hash context should return 2. The optimizations used in HashVersion{2} include a number of changes to the hash-trait implementations that do not alter the documented behavior but do change the actual hash value returned because of how and when elements get hashed.\n\n\n\n\n\n","category":"function"},{"location":"api/#StableHashTraits.TablesEq","page":"API","title":"StableHashTraits.TablesEq","text":"TablesEq(parent_context)\n\nIn this hash context the type and structure of a table do not impact the hash that is created, only the set of columns (as determined by Tables.columns), and the hash of the individual columns matter.\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.ViewsEq","page":"API","title":"StableHashTraits.ViewsEq","text":"ViewsEq(parent_context)\n\nCreate a hash context where only the contents of an array or string determine its hash: that is, the type of the array or string (e.g. SubString vs. String) does not impact the hash value.\n\nwarn: Deprecated\nIn HashVersion{3} this is already true, so there is no need for ViewsEq. This does not change the behavior of HashVersion{3} or later.\n\n\n\n\n\n","category":"type"},{"location":"api/#StableHashTraits.WithTypeNames","page":"API","title":"StableHashTraits.WithTypeNames","text":"WithTypeNames(parent_context)\n\nIn this hash context, not only the structure, but also the name of the type (e.g. Array vs. SubArray) affects the hashed value.\n\n\n\n\n\n","category":"type"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"Deprecated API:","category":"page"},{"location":"deprecated/","page":"Deprecated","title":"Deprecated","text":"StableHashTraits.hash_method\nstable_typename_id\nstable_type_id\nStableHashTraits.write\nHashAndContext","category":"page"},{"location":"deprecated/#StableHashTraits.hash_method","page":"Deprecated","title":"StableHashTraits.hash_method","text":"StableHashTraits.hash_method(x, [context])\n\nRetrieve the trait object that indicates how a type should be hashed using stable_hash. You should return one of the following values.\n\nWriteHash(): writes the object to a binary format using StableHashTraits.write(io, x)  and takes a hash of that. StableHashTraits.write(io, x) falls back to Base.write(io,  x) if no specialized methods are defined for x.\nIterateHash(): assumes the object is iterable and finds a hash of all elements\nStructHash([pair = (fieldnames ∘ typeof) => getfield], [order]): hash the structure of  the object as defined by a sequence of pairs. How precisely this occurs is determined by  the two arguments:\npair Defines how fields are extracted; the default is fieldnames ∘ typeof => getfield but this could be changed to e.g. propertynames => getproperty or Tables.columnnames => Tables.getcolumn. The first element of the pair is a function used to compute a list of keys and the second element is a two argument function used to extract the keys from the object.\norder can be :ByOrder (the default)—which sorts by the order returned by pair[1]—or :ByName—which sorts by lexigraphical order.\nFnHash(fn, [method]): hash the result of applying fn to the given object. Optionally, use method to hash the result of fn, otherwise calls hash_method on the result to determine how to hash it. There are two built-in functions commonly used with FnHash.\nstable_typename_id: Get the qualified name of an object's type, e.g. Base.String and return 64 bit hash of this string\nstable_type_id: Get the qualified name and type parameters of a type, e.g.  Base.Vector{Int}, and return a 64 bit hash of this string.\n@ConstantHash(x): at compile time, hash the literal (constant) string or number using  sha256 and include the first 64 bits as a constant number that is recursively hashed  using the WriteHash method.\nTuple: apply multiple methods to hash the object, and then recursively hash their  results. For example: (@ConstantHash(\"header\"), StructHash()) would compute a hash for  both the string \"header\" and the fields of the object, and then recursively hash these  two hashes.\n\nYour hash will be stable if the output for the given method remains the same: e.g. if write is the same for an object that uses WriteHash, its hash will be the same; if the fields are the same for StructHash, the hash will be the same; etc...\n\nMissing from the above list is one final, advanced, trait: HashAndContext which can be used to change the context within the scope of a given object.\n\nCustomizing hash computations with contexts\n\nYou can customize how hashes are computed within a given scope using a context object. This is also a very useful way to avoid type piracy. The context can be any object you'd like and is passed as the second argument to stable_hash. By default it is equal to HashVersion{1}() and this determines how objects are hashed when a more specific method is not defined.\n\nThis context is then passed to both hash_method and StableHashTraits.write (the latter is the method called for WriteHash, and falls back to Base.write). Because of the way the root contexts (HashVersion{1} and HashVersion{2}) are defined, you normally don't have to include this context as an argument when you define a method of hash_context or write because there are appropriate fallback methods.\n\nWhen you define a hash context it should normally accept a parent context that serves as a fallback, and return it in an implementation of the method StableHashTraits.parent_context.\n\nAs an example, here is how we could write a context that treats all named tuples with the same keys and values as equivalent.\n\nstruct NamedTuplesEq{T}\n    parent::T\nend\nStableHashTraits.parent_context(x::NamedTuplesEq) = x.parent\nfunction StableHashTraits.hash_method(::NamedTuple, ::NamedTuplesEq)\n    return FnHash(stable_typename_id), StructHash(:ByName)\nend\ncontext = NamedTuplesEq(HashVersion{2}())\nstable_hash((; a=1:2, b=1:2), context) == stable_hash((; b=1:2, a=1:2), context) # true\n\nIf we instead defined parent_context to return nothing, our context would need to implement a hash_method that covered the types AbstractRange, Int64, Symbol and Pair for the call to stable_hash above to succeed.\n\nCustomizing hashes within an object\n\nContexts can be customized not only when you call stable_hash but also when you hash the contents of a particular object. This lets you change how hashing occurs within the object. See the docstring of HashAndContext for details.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/#StableHashTraits.stable_typename_id","page":"Deprecated","title":"StableHashTraits.stable_typename_id","text":"stable_typename_id(x)\n\nReturns a 64 bit hash that is the same for a given type so long as the name and the module of the type doesn't change.\n\nExample\n\njulia> stable_typename_id([1, 2, 3])\n0x56c6b9ca080a0aa4\n\njulia> stable_typename_id([\"a\", \"b\"])\n0x56c6b9ca080a0aa4\n\nnote: Note\nIf the module of a type is Core it is renamed to Base before hashing because the location of some types changes between Core to Base across julia versions. Likewise, the type names of AbstractArray types are made uniform as their printing changes from Julia 1.6 -> 1.7.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/#StableHashTraits.stable_type_id","page":"Deprecated","title":"StableHashTraits.stable_type_id","text":"stable_type_id(x)\n\nReturns a 64 bit hash that is the same for a given type so long as the module, and string representation of a type is the same (invariant to comma spacing).\n\nExample\n\njulia> stable_type_id([1, 2, 3])\n0xfd5878e59e259648\n\njulia> stable_type_id([\"a\", \"b\"])\n0xe191f67c4c8e3370\n\nnote: Note\nIf the module of a type is Core it is renamed to Base before hashing because the location of some types changes between Core to Base across julia versions. Likewise, the type names of AbstractArray types are made uniform as their printing changes from Julia 1.6 -> 1.7.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/#StableHashTraits.write","page":"Deprecated","title":"StableHashTraits.write","text":"StableHashTraits.write(io, x, [context])\n\nWrites contents of x to an io buffer to be hashed during a call to stable_hash. Fall back methods are defined as follows:\n\nwrite(io, x, context) = write(io, x)\nwrite(io, x) = Base.write(io, x)\n\nUsers of StableHashTraits can overwrite either the 2 or 3 argument version for their types to customize the behavior of stable_hash.\n\nSee also: StableHashTraits.hash_method.\n\n\n\n\n\n","category":"function"},{"location":"deprecated/#StableHashTraits.HashAndContext","page":"Deprecated","title":"StableHashTraits.HashAndContext","text":"HashAndContext(method, old_context -> new_context)\n\nA special hash method that changes the context when hashing the contents of an object. The method defines how the object itself should be hashed and the second argument is a callable which transforms the old context to the new.\n\nFor example, here is how we can make sure the arrays in a specific object have a hash that is invariant to endianness without having to copy the array.\n\nstruct EndianInvariant{P}\n    parent_context::P\nend\nStableHashTraits.parent_context(x::EndianInvariant) = x.parent_context\n\nstruct CrossPlatformData\n    data::Vector{Int}\nend\n\nStableHashTraits.hash_method(::Number, ::EndianInvariant) = FnHash(htol, WriteHash())\nStableHashTraits.hash_method(::CrossPlatformData) = HashAndContext(IterateHash(), EndianInvariant)\n\nNote that we could accomplish this same behavior using FnHash(x -> htol.(x.data)), but it would require copying that data to do so.\n\n\n\n\n\n","category":"type"},{"location":"internal/#Internal-Methods","page":"Internal Functions","title":"Internal Methods","text":"","category":"section"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"Documented methods that are not part of the public API.","category":"page"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"StableHashTraits.hash_type!\nStableHashTraits.hash_value!\nStableHashTraits.HashState\nStableHashTraits.similar_hash_state\nStableHashTraits.start_nested_hash!\nStableHashTraits.end_nested_hash!\nStableHashTraits.update_hash!\nStableHashTraits.compute_hash!","category":"page"},{"location":"internal/#StableHashTraits.hash_type!","page":"Internal Functions","title":"StableHashTraits.hash_type!","text":"hash_type!(hash_state, context, T)\n\nHash type T in the given context to hash_state. The result is cached and future calls to hash_type! will hash the cached result.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.hash_value!","page":"Internal Functions","title":"StableHashTraits.hash_value!","text":"hash_value!(x, hash_state, context, trait)\n\nHash the value of object x to the hash_state for the given context and hash trait. Caches types, larger values and those objects manually flagged to be cached.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.HashState","page":"Internal Functions","title":"StableHashTraits.HashState","text":"HashState(alg, context)\n\nGiven a function that implements the hash algorithm to use and the current hash context, setup the necessary state to track updates to hashing as we traverse an object's structure and return it.\n\n\n\n\n\n","category":"type"},{"location":"internal/#StableHashTraits.similar_hash_state","page":"Internal Functions","title":"StableHashTraits.similar_hash_state","text":"similar_hash_state(state::HashState)\n\nAkin to similar for arrays, this constructs a new object of the same concrete type as state\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.start_nested_hash!","page":"Internal Functions","title":"StableHashTraits.start_nested_hash!","text":"start_nested_hash!(state::HashState)\n\nReturn an updated state that delimits hashing of a nested structure; calls made to update_hash! after startnestedhash! will be handled as nested elements up until end_nested_hash! is called.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.end_nested_hash!","page":"Internal Functions","title":"StableHashTraits.end_nested_hash!","text":"end_nested_hash!(state::HashState)\n\nReturn an updated state that delimints the end of a nested structure.\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.update_hash!","page":"Internal Functions","title":"StableHashTraits.update_hash!","text":"update_hash!(state::HashState, bytes)\n\nReturns the updated hash state given a set of bytes (either a tuple or array of UInt8 values).\n\nupdate_hash!(state::HashState, obj, context)\n\nReturns the updated hash, given an object and some context. The object will be written to some bytes using StableHashTraits.write(io, obj, context).\n\n\n\n\n\n","category":"function"},{"location":"internal/#StableHashTraits.compute_hash!","page":"Internal Functions","title":"StableHashTraits.compute_hash!","text":"compute_hash!(state::HashState)\n\nReturn the final hash value to return for state\n\n\n\n\n\n","category":"function"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"Deprecated, non-public API methods; these will be deleted when the deprecated functionality is removed.","category":"page"},{"location":"internal/","page":"Internal Functions","title":"Internal Functions","text":"StableHashTraits.stable_typefields_id","category":"page"},{"location":"internal/#StableHashTraits.stable_typefields_id","page":"Internal Functions","title":"StableHashTraits.stable_typefields_id","text":"stable_typefields_id(x)\n\nReturns a 64 bit hash that is the same for a given type so long as the set of field names remains unchanged.\n\n\n\n\n\n","category":"function"},{"location":"#StableHashTraits","page":"Manual","title":"StableHashTraits","text":"","category":"section"},{"location":"#Use-Case-and-Design-Rationale","page":"Manual","title":"Use Case and Design Rationale","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"StableHashTraits is designed to be used in cases where there is an object you wish to serialize in a content-addressed cache. How and when objects pass the same input to a hashing algorithm is meant to be predictable and well defined, so that the user can reliably define methods of transformer to modify this behavior.","category":"page"},{"location":"#What-gets-hashed?","page":"Manual","title":"What gets hashed?","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"By default, an object is hashed according to its StructType (ala SructTypes), and this can be customized using StableHashTraits.transformer.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Hashing makes use of stable_type_name which generates string(parentmodule(T)) * \".\" * string(nameof(T)) for type T, with a few additional regularizations to ensure e.g. Core. values become Base. values (as what is in Core vs. Base changes across julia versions). This function also ensures that no anonymous values (those that include #) are hashed, as these are not stable across sessions.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Type: when hashing the type of an object or its contained types, only the name of stable_type_name(StructType(T)) is hashed along with any structure as determined by the particular return value of StructType(T) (e.g. eltype for ArrayType). If you hash a type as a value (e.g. stable_hash(Int)) the stable_type_name of the type itself, rather than StructType(T) is used.\nStructType.DataType — the fieldnames, fieldtypes and the field values are hashed, and if this is a StructType.UnorderedStruct those are all sorted in lexicographic order of the fieldnames. StructType.UnorderedStruct is the default struct-type trait so this is how most objects get hashed.\nStructType.ArrayType — the eltype is hashed and elements are hashed using iterate.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If StableHashTraits.is_ordered returns false the elements are first sorted according to StableHashTraits.hash_sort_by.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"StructType.DictType — the eltype of the keys and values are hashed by iterating over StructTypes.keyvaluepairs. If StableHashTraits.is_ordered returns false the pairs of the dictionary are first sorted according their keys using StableHashTraits.hash_sort_by.\nStructType.CustomStruct - the object is first StructType.lowered and the result is hashed according to its StructType.\nStructType.NullType, StructType.SingletonType: in these cases the stable_type_name of the type T is hashed rather than StructType(T)\nStructType.NumberType, StructType.StringType, StructType.BoolType: the the type of the object is hashed along with its bytes\nFunction: functions are a special case and their stable_type_name is hashed along with their fieldnames, fieldtypes and fieldvalues. Functions have fields when they are curried, e.g. ==(2) or when they are defined via a struct definition.\nAbstractRange: though their StructType is AbstractArray, abstract ranges are treated as UnorderedStruct objects for purposes of hashing, as this normally leads to a more effeicient hash computation.\nAbstractArray: in addition to hashing the eltype, any abstract array type with a concrete dimension (AbstractArray{<:Any, 3} but not AbstractArray{Int}) will hash this dimension. The size of an array is hashed along with the array contents.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"[!WARNING] Some type parameters are ignored by this hashing scheme; specifically, the only parameters hashed are those specified above. This means, for example, that a parameter not included in fieldtype(T) for StructType(T) == StructTypes.Struct will be ignored during hashing. You can use StableHashTraits.type_structure to explicitly hash additional type parameters for a type.","category":"page"},{"location":"#Examples","page":"Manual","title":"Examples","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"All of the following hash examples follow directly from the definitions above, but may not be so obvious to the reader.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Most of the behaviors described below can be customized/changed by using your own hash context, which can be passed as the second argument to stable_hash.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"The order of NamedTuple pairs does not matter","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash((;a=1,b=2); version=3) == stable_hash((;b=2,a=1); version=3)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Two structs with the same fields hash equivalently","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"struct X\n    bar::Int\n    foo::Float64\nend\n\nstruct Y\n    foo::Float64\n    bar::Int\nend\n\nstable_hash(X(2, 1); version=3) == stable_hash(Y(1, 2); version=3)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Different array types with the same content hash to the same value.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash(view([1,2,3], 1:2); version=3) == stable_hash([1,2]; version=3)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Byte equivalent arrays of all NumberType values will hash to the same value.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash([0.0, 0.0]; version=3) == stable_hash([0, 0]; version=3)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"But if the eltype has a different StructType, or if the bytes are different, the collision will not occur.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"stable_hash(Any[0.0, 0.0]; version=3) != stable_hash([0, 0]; version=3)\nstable_hash([1.0, 2.0]; version=3) != stable_hash([1, 2]; version=3)","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Numerical changes will, of course, change the hash. One way this can catch you off guard are some differences in StaticArray outputs between julia versions:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> using StaticArrays, StableHashTraits;\n\njulia> begin\n        rotmatrix2d(a) = @SMatrix [cos(a) sin(a); -sin(a) cos(a)]\n        rotate(a, p) = rotmatrix2d(a) * p\n        rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))\n    end;","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In julia 1.9.4:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"\njulia> bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=3))\n\"4ccdc172688dd2b5cd50ba81071a19217c3efe2e3b625e571542004c8f96c797\"\n\njulia> rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))\n2-element SVector{2, Float64} with indices SOneTo(2):\n  7.419375817039376e-17\n -0.5953242152248626","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In julia 1.6.7","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=3))\n\"3b8d998f3106c05f8b74ee710267775d0d0ce0e6780c1256f4926d3b7dcddf9e\"\n\njulia> rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))\n2-element SVector{2, Float64} with indices SOneTo(2):\n  5.551115123125783e-17\n -0.5953242152248626","category":"page"},{"location":"#Basic-Customization","page":"Manual","title":"Basic Customization","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"You typically want to simply override a method of StableHashTraits.transformer. This should return a function wrapped in a StableHashTraits.Transformer object that will be applied to an object and its result is the actual value that gets hashed.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"using StableHashTraits\nusing StableHashTraits: Transformer\nusing Dates\n\nstruct MyType\n   data::Vector{UInt8}\n   metadata::Dict{Symbol, Any}\nend\n# ignore `metadata`, `data` will be hashed using fallbacks for `AbstractArray` type\nStableHashTraits.transformer(::Type{<:MyType}) = Transformer(x -> (; x.data);\n                                                             preserves_structure=true)\na = MyType(read(\"myfile.txt\"), Dict{Symbol, Any}(:read => Dates.now()))\nb = MyType(read(\"myfile.txt\"), Dict{Symbol, Any}(:read => Dates.now()))\nstable_hash(a; version=3) == stable_hash(b; version=3) # true","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"In this example we also optimize our hash by setting preserves_structure=true. You can do this any time your function is type stable, but there are additional conditions under which you can still set this flag to true, discussed below.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"StableHashTraits.Transformer takes a second positional argument which is the StructType you wish to use on the transformed return value. By default StructType is applied to the result to determine this automatically, but in some cases it can be useful to modify this trait by passing a second argument (see the example below).","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"To avoid StackOverflow errors make sure you don't return the object itself as an element of some collection. It can be tempting to do e.g. (mymetadata(x), x) as a return value for transformer's function. Instead you can use StableHashTraits.TransformIdentity to make sure this won't lead to an infinite regress: e.g. (mymetadata(x), TransformIdentity(x)). Using StableHashTraits.TransformIdentity will cause x's transformed result to be x itself, thereby avoiding the infinite regress.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"transformer customizes how the content of your object is hashed. The hash of the type and any structure is customized separately. If you wish to customize how the type of an object is hashed, read on.","category":"page"},{"location":"#Using-Contexts","page":"Manual","title":"Using Contexts","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Because not every package knows about either StableHashTraits or StructTypes, there may be types you don't own that you want to customize the hash of. In this scenario you should define a context object that you pass as the second argument to stable_hash and define a method of transformer that dispatches on this context object as its second argument.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"A context is simply an arbitrary object that defines a method for StableHashTraits.parent_context. By default the context to stable_hash is HashVersion{version}(). Because of parent_context, contexts can be stacked, and a HashVersion should be at the bottom of the stack. There are fallback methods for transformer that look at the value implemented by the parent context. In this way you need only define methods for the types you want to customize.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"For example, this customization makes the ordering of named tuple keys affect the hash value.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"julia> begin\n        struct NamedTuplesOrdered{T}\n            parent::T\n        end\n        StableHashTraits.parent_context(x::NamedTuplesOrdered) = x.parent\n        function transformer(::Type{<:NamedTuple}, ::NamedTuplesOrdered)\n            Transformer(identity, StructTypes.OrderedStruct())\n        end\n        context = NamedTuplesOrdered(HashVersion{3}())\n       end;\n\njulia> stable_hash((; a=1:2, b=1:2), context) != stable_hash((; b=1:2, a=1:2), context)\ntrue","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"Without this context, the keys are first sorted because StructType(NamedTuple) isa StructType.UnorderedStruct.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"There are two useful, predefined contexts available in StableHashTraits that can be used to change how hashing works:","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"WithTypeNames\nTablesEq","category":"page"},{"location":"#Optimizing-Transformers","page":"Manual","title":"Optimizing Transformers","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"As noted preserves_structure can safely be set to true for any type-stable function. It is set to true by default for identity. When set to true, stable_hash will hoist type hashes outside of loops when possible, avoiding type hashes for any deeply nested fields, so long as the path to them includes all concrete types. For example, when hashing an Array{Int} the Int will only be hashed once, not once for every element.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"When preserves_structure=false (the default for most functions) the type of the return value from transformer is always hashed alongside the transformed value.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"This should give the reader some idea of when a type-unstable function can be safely marked as preserves_structure=true. In particular any case where each value passed to transform maps to a value that will be hashed as a unique bit-sequence should be fine. This would be violated, for instance, by x -> x < 0 : Char(0) ? Int32(0), but not by x -> x < 0 : Char(1) : Int32(2). In the latter case we could safely mark preserves_structure=true.","category":"page"},{"location":"#Customizing-Type-Hashes","page":"Manual","title":"Customizing Type Hashes","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"Types are hashed by hashing a type name and a type structure. The structure is determined by the StructType as detailed above (e.g. ArrayTypes hash their eltype). As noted there, the name will be based on the name of the StructType when hashing the type of an object, and the name of the type itself when hashing the type as a value.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"You can change how a type name is hashed for an object using StableHashTraits.type_hash_name, how a type name is hashed as a value using StableHashTraits.type_value_name and how the structure is hashed using StableHashTraits.type_structure. The latter is necessary to overwrite if you want to differentiate types that vary only in their type parameters, not their fieldtypes or eltype.","category":"page"},{"location":"#Caching","page":"Manual","title":"Caching","text":"","category":"section"},{"location":"","page":"Manual","title":"Manual","text":"StableHashTraits caches hash results for all types and large values. This cache is initialized per call to stable_hash; to leverage the same cache over multiple calls you can create a CachedHash,","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"context = CachedHash(HashVersion{3}())\nstable_hash(x, context)\nstable_hash(y, context) # previously cached values will be re-used","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"However, if you change or add any method definitions that are used to customize hashes (e.g. StableHashTraits.transformer) you will need to create a new context to avoid using stale method results.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"If you know that a particular object will be hashed repeatedly, you can make sure that it is cached by wrapping it in a StableHashTraits.UseCache object during a call to StableHashTraits.transformer.","category":"page"},{"location":"","page":"Manual","title":"Manual","text":"using StableHashTraits\nusing StableHashTraits: Transformer, UseCache\n\nstruct Foo\n    x::Int\n    ref::Bar\nend\n\nstruct Bar\n    data::Vector{Int}\nend\n\nfoos = Foo.(rand(Int, 10_000), Ref(Bar(rand(Int, 1_000))))\n# do not repeatedly hash `Bar`:\ntransformer(::Type{<:Bar}) = Transformer(UseCache)","category":"page"}]
}
