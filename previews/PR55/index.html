<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · StableHashTraits.jl</title><meta name="title" content="Manual · StableHashTraits.jl"/><meta property="og:title" content="Manual · StableHashTraits.jl"/><meta property="twitter:title" content="Manual · StableHashTraits.jl"/><meta name="description" content="Documentation for StableHashTraits.jl."/><meta property="og:description" content="Documentation for StableHashTraits.jl."/><meta property="twitter:description" content="Documentation for StableHashTraits.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>StableHashTraits.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Use-Case-and-Design-Rationale"><span>Use Case and Design Rationale</span></a></li><li><a class="tocitem" href="#What-gets-hashed?"><span>What gets hashed?</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Basic-Customization"><span>Basic Customization</span></a></li><li><a class="tocitem" href="#Using-Contexts"><span>Using Contexts</span></a></li><li><a class="tocitem" href="#Optimizing-Transformers"><span>Optimizing Transformers</span></a></li><li><a class="tocitem" href="#Customizing-Type-Hashes"><span>Customizing Type Hashes</span></a></li><li><a class="tocitem" href="#Caching"><span>Caching</span></a></li></ul></li><li><a class="tocitem" href="api/">API</a></li><li><a class="tocitem" href="deprecated/">Deprecated</a></li><li><a class="tocitem" href="internal/">Internal Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/beacon-biosignals/StableHashTraits.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/beacon-biosignals/StableHashTraits.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="StableHashTraits"><a class="docs-heading-anchor" href="#StableHashTraits">StableHashTraits</a><a id="StableHashTraits-1"></a><a class="docs-heading-anchor-permalink" href="#StableHashTraits" title="Permalink"></a></h1><h2 id="Use-Case-and-Design-Rationale"><a class="docs-heading-anchor" href="#Use-Case-and-Design-Rationale">Use Case and Design Rationale</a><a id="Use-Case-and-Design-Rationale-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Case-and-Design-Rationale" title="Permalink"></a></h2><p>StableHashTraits is designed to be used in cases where there is an object you wish to serialize in a content-addressed cache. How and when objects pass the same input to a hashing algorithm is meant to be predictable and well defined, so that the user can reliably define methods of <code>transformer</code> to modify this behavior.</p><h2 id="What-gets-hashed?"><a class="docs-heading-anchor" href="#What-gets-hashed?">What gets hashed?</a><a id="What-gets-hashed?-1"></a><a class="docs-heading-anchor-permalink" href="#What-gets-hashed?" title="Permalink"></a></h2><p>By default, an object is hashed according to its <code>StructType</code> (ala <a href="https://github.com/JuliaData/StructTypes.jl">SructTypes</a>), and this can be customized using <a href="api/#StableHashTraits.transformer"><code>StableHashTraits.transformer</code></a>.</p><p>Hashing makes use of <a href="api/#StableHashTraits.stable_type_name"><code>stable_type_name</code></a> which generates <code>string(parentmodule(T)) * &quot;.&quot; * string(nameof(T))</code> for type <code>T</code>, with a few additional regularizations to ensure e.g. <code>Core.</code> values become <code>Base.</code> values (as what is in <code>Core</code> vs. <code>Base</code> changes across julia versions). This function also ensures that no anonymous values (those that include <code>#</code>) are hashed, as these are not stable across sessions.</p><ul><li><p><code>Type</code>: when hashing the type of an object or its contained types, only the name of <code>stable_type_name(StructType(T))</code> is hashed along with any structure as determined by the particular return value of <code>StructType(T)</code> (e.g. <code>eltype</code> for <code>ArrayType</code>). If you hash a type as a value (e.g. <code>stable_hash(Int)</code>) the <code>stable_type_name</code> of the type itself, rather than <code>StructType(T)</code> is used.</p></li><li><p><code>StructType.DataType</code> — the <code>fieldnames</code>, <code>fieldtypes</code> and the field values are hashed, and if this is a <code>StructType.UnorderedStruct</code> those are all sorted in lexicographic order of the fieldnames. <code>StructType.UnorderedStruct</code> is the default struct-type trait so this is how most objects get hashed.</p></li><li><p><code>StructType.ArrayType</code> — the <code>eltype</code> is hashed and elements are hashed using <code>iterate</code>.</p></li></ul><p>If <a href="api/#StableHashTraits.is_ordered"><code>StableHashTraits.is_ordered</code></a> returns <code>false</code> the elements are first <code>sort</code>ed according to <a href="api/#StableHashTraits.hash_sort_by"><code>StableHashTraits.hash_sort_by</code></a>.</p><ul><li><p><code>StructType.DictType</code> — the <code>eltype</code> of the keys and values are hashed by iterating over <code>StructTypes.keyvaluepairs</code>. If <a href="api/#StableHashTraits.is_ordered"><code>StableHashTraits.is_ordered</code></a> returns <code>false</code> the pairs of the dictionary are first <code>sort</code>ed according their keys using <a href="api/#StableHashTraits.hash_sort_by"><code>StableHashTraits.hash_sort_by</code></a>.</p></li><li><p><code>StructType.CustomStruct</code> - the object is first <code>StructType.lower</code>ed and the result is hashed according to its <code>StructType</code>.</p></li><li><p><code>StructType.NullType</code>, <code>StructType.SingletonType</code>: in these cases the <code>stable_type_name</code> of the type <code>T</code> is hashed rather than <code>StructType(T)</code></p></li><li><p><code>StructType.NumberType</code>, <code>StructType.StringType</code>, <code>StructType.BoolType</code>: the the type of the object is hashed along with its bytes</p></li><li><p><code>Function</code>: functions are a special case and their <code>stable_type_name</code> is hashed along with their fieldnames, fieldtypes and fieldvalues. Functions have fields when they are curried, e.g. <code>==(2)</code> or when they are defined via a <code>struct</code> definition.</p></li><li><p><code>AbstractRange</code>: though their <code>StructType</code> is <code>AbstractArray</code>, abstract ranges are treated as <code>UnorderedStruct</code> objects for purposes of hashing, as this normally leads to a more effeicient hash computation.</p></li><li><p><code>AbstractArray</code>: in addition to hashing the <code>eltype</code>, any abstract array type with a concrete dimension (<code>AbstractArray{&lt;:Any, 3}</code> but not <code>AbstractArray{Int}</code>) will hash this dimension. The size of an array is hashed along with the array contents.</p></li></ul><blockquote><p>[!WARNING] Some type parameters are ignored by this hashing scheme; specifically, the only parameters hashed are those specified above. This means, for example, that a parameter not included in <code>fieldtype(T)</code> for <code>StructType(T) == StructTypes.Struct</code> will be ignored during hashing. You can use <a href="api/#StableHashTraits.type_structure"><code>StableHashTraits.type_structure</code></a> to explicitly hash additional type parameters for a type.</p></blockquote><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>All of the following hash examples follow directly from the definitions above, but may not be so obvious to the reader.</p><p>Most of the behaviors described below can be customized/changed by using your own hash context, which can be passed as the second argument to <a href="api/#StableHashTraits.stable_hash"><code>stable_hash</code></a>.</p><p>The order of NamedTuple pairs does not matter</p><pre><code class="language-julia hljs">stable_hash((;a=1,b=2); version=3) == stable_hash((;b=2,a=1); version=3)</code></pre><p>Two structs with the same fields hash equivalently</p><pre><code class="language-julia hljs">struct X
    bar::Int
    foo::Float64
end

struct Y
    foo::Float64
    bar::Int
end

stable_hash(X(2, 1); version=3) == stable_hash(Y(1, 2); version=3)</code></pre><p>Different array types with the same content hash to the same value.</p><pre><code class="language-julia hljs">stable_hash(view([1,2,3], 1:2); version=3) == stable_hash([1,2]; version=3)</code></pre><p>Byte equivalent arrays of all <code>NumberType</code> values will hash to the same value.</p><pre><code class="language-julia hljs">stable_hash([0.0, 0.0]; version=3) == stable_hash([0, 0]; version=3)</code></pre><p>But if the eltype has a different <code>StructType</code>, or if the bytes are different, the collision will not occur.</p><pre><code class="language-julia hljs">stable_hash(Any[0.0, 0.0]; version=3) != stable_hash([0, 0]; version=3)
stable_hash([1.0, 2.0]; version=3) != stable_hash([1, 2]; version=3)</code></pre><p>Numerical changes will, of course, change the hash. One way this can catch you off guard are some differences in <code>StaticArray</code> outputs between julia versions:</p><pre><code class="language-julia hljs">julia&gt; using StaticArrays, StableHashTraits;

julia&gt; begin
        rotmatrix2d(a) = @SMatrix [cos(a) sin(a); -sin(a) cos(a)]
        rotate(a, p) = rotmatrix2d(a) * p
        rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))
    end;</code></pre><p>In julia 1.9.4:</p><pre><code class="language-julia hljs">
julia&gt; bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=3))
&quot;4ccdc172688dd2b5cd50ba81071a19217c3efe2e3b625e571542004c8f96c797&quot;

julia&gt; rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))
2-element SVector{2, Float64} with indices SOneTo(2):
  7.419375817039376e-17
 -0.5953242152248626</code></pre><p>In julia 1.6.7</p><pre><code class="language-julia hljs">julia&gt; bytes2hex(stable_hash(rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006)); version=3))
&quot;3b8d998f3106c05f8b74ee710267775d0d0ce0e6780c1256f4926d3b7dcddf9e&quot;

julia&gt; rotate((pi / 4), SVector{2}(0.42095778959006, -0.42095778959006))
2-element SVector{2, Float64} with indices SOneTo(2):
  5.551115123125783e-17
 -0.5953242152248626</code></pre><h2 id="Basic-Customization"><a class="docs-heading-anchor" href="#Basic-Customization">Basic Customization</a><a id="Basic-Customization-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Customization" title="Permalink"></a></h2><p>You typically want to simply override a method of <a href="api/#StableHashTraits.transformer"><code>StableHashTraits.transformer</code></a>. This should return a function wrapped in a <a href="api/#StableHashTraits.Transformer"><code>StableHashTraits.Transformer</code></a> object that will be applied to an object and its result is the actual value that gets hashed.</p><pre><code class="language-julia hljs">using StableHashTraits
using StableHashTraits: Transformer
using Dates

struct MyType
   data::Vector{UInt8}
   metadata::Dict{Symbol, Any}
end
# ignore `metadata`, `data` will be hashed using fallbacks for `AbstractArray` type
StableHashTraits.transformer(::Type{&lt;:MyType}) = Transformer(x -&gt; (; x.data);
                                                             preserves_structure=true)
a = MyType(read(&quot;myfile.txt&quot;), Dict{Symbol, Any}(:read =&gt; Dates.now()))
b = MyType(read(&quot;myfile.txt&quot;), Dict{Symbol, Any}(:read =&gt; Dates.now()))
stable_hash(a; version=3) == stable_hash(b; version=3) # true</code></pre><p>In this example we also optimize our hash by setting <code>preserves_structure=true</code>. You can do this any time your function is type stable, but there are additional conditions under which you can still set this flag to true, discussed below.</p><p><a href="api/#StableHashTraits.Transformer"><code>StableHashTraits.Transformer</code></a> takes a second positional argument which is the <code>StructType</code> you wish to use on the transformed return value. By default <code>StructType</code> is applied to the result to determine this automatically, but in some cases it can be useful to modify this trait by passing a second argument (see the example below).</p><p><strong>To avoid StackOverflow errors</strong> make sure you don&#39;t return the object itself as an element of some collection. It can be tempting to do e.g. <code>(mymetadata(x), x)</code> as a return value for <code>transformer</code>&#39;s function. Instead you can use <a href="api/#StableHashTraits.TransformIdentity"><code>StableHashTraits.TransformIdentity</code></a> to make sure this won&#39;t lead to an infinite regress: e.g. <code>(mymetadata(x), TransformIdentity(x))</code>. Using <a href="api/#StableHashTraits.TransformIdentity"><code>StableHashTraits.TransformIdentity</code></a> will cause <code>x</code>&#39;s transformed result to be <code>x</code> itself, thereby avoiding the infinite regress.</p><p><code>transformer</code> customizes how the <em>content</em> of your object is hashed. The hash of the type and any structure is customized separately. If you wish to customize how the type of an object is hashed, read on.</p><h2 id="Using-Contexts"><a class="docs-heading-anchor" href="#Using-Contexts">Using Contexts</a><a id="Using-Contexts-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Contexts" title="Permalink"></a></h2><p>Because not every package knows about either <code>StableHashTraits</code> or <code>StructTypes</code>, there may be types you don&#39;t own that you want to customize the hash of. In this scenario you should define a context object that you pass as the second argument to <code>stable_hash</code> and define a method of <code>transformer</code> that dispatches on this context object as its second argument.</p><p>A context is simply an arbitrary object that defines a method for <a href="api/#StableHashTraits.parent_context"><code>StableHashTraits.parent_context</code></a>. By default the context to <code>stable_hash</code> is <code>HashVersion{version}()</code>. Because of <code>parent_context</code>, contexts can be stacked, and a <code>HashVersion</code> should be at the bottom of the stack. There are fallback methods for <code>transformer</code> that look at the value implemented by the parent context. In this way you need only define methods for the types you want to customize.</p><p>For example, this customization makes the ordering of named tuple keys affect the hash value.</p><pre><code class="language- hljs">julia&gt; begin
        struct NamedTuplesOrdered{T}
            parent::T
        end
        StableHashTraits.parent_context(x::NamedTuplesOrdered) = x.parent
        function transformer(::Type{&lt;:NamedTuple}, ::NamedTuplesOrdered)
            Transformer(identity, StructTypes.OrderedStruct())
        end
        context = NamedTuplesOrdered(HashVersion{3}())
       end;

julia&gt; stable_hash((; a=1:2, b=1:2), context) != stable_hash((; b=1:2, a=1:2), context)
true</code></pre><p>Without this context, the keys are first sorted because <code>StructType(NamedTuple) isa StructType.UnorderedStruct</code>.</p><p>There are two useful, predefined contexts available in <code>StableHashTraits</code> that can be used to change how hashing works:</p><ul><li><a href="api/#StableHashTraits.WithTypeNames"><code>WithTypeNames</code></a></li><li><a href="api/#StableHashTraits.TablesEq"><code>TablesEq</code></a></li></ul><h2 id="Optimizing-Transformers"><a class="docs-heading-anchor" href="#Optimizing-Transformers">Optimizing Transformers</a><a id="Optimizing-Transformers-1"></a><a class="docs-heading-anchor-permalink" href="#Optimizing-Transformers" title="Permalink"></a></h2><p>As noted <code>preserves_structure</code> can safely be set to true for any type-stable function. It is set to true by default for <code>identity</code>. When set to true, <code>stable_hash</code> will hoist type hashes outside of loops when possible, avoiding type hashes for any deeply nested fields, so long as the path to them includes all concrete types. For example, when hashing an <code>Array{Int}</code> the <code>Int</code> will only be hashed once, not once for every element.</p><p>When <code>preserves_structure=false</code> (the default for most functions) the type of the return value from <code>transformer</code> is always hashed alongside the transformed value.</p><p>This should give the reader some idea of when a type-unstable function can be safely marked as <code>preserves_structure=true</code>. In particular any case where each value passed to transform maps to a value that will be hashed as a unique bit-sequence should be fine. This would be violated, for instance, by <code>x -&gt; x &lt; 0 : Char(0) ? Int32(0)</code>, but not by <code>x -&gt; x &lt; 0 : Char(1) : Int32(2)</code>. In the latter case we could safely mark <code>preserves_structure=true</code>.</p><h2 id="Customizing-Type-Hashes"><a class="docs-heading-anchor" href="#Customizing-Type-Hashes">Customizing Type Hashes</a><a id="Customizing-Type-Hashes-1"></a><a class="docs-heading-anchor-permalink" href="#Customizing-Type-Hashes" title="Permalink"></a></h2><p>Types are hashed by hashing a type name and a type structure. The structure is determined by the <code>StructType</code> as detailed above (e.g. <code>ArrayType</code>s hash their <code>eltype</code>). As noted there, the name will be based on the name of the <code>StructType</code> when hashing the type of an object, and the name of the type itself when hashing the type as a value.</p><p>You can change how a type name is hashed for an object using <a href="api/#StableHashTraits.type_hash_name"><code>StableHashTraits.type_hash_name</code></a>, how a type name is hashed as a value using <a href="api/#StableHashTraits.type_value_name"><code>StableHashTraits.type_value_name</code></a> and how the structure is hashed using <a href="api/#StableHashTraits.type_structure"><code>StableHashTraits.type_structure</code></a>. The latter is necessary to overwrite if you want to differentiate types that vary only in their type parameters, not their <code>fieldtypes</code> or <code>eltype</code>.</p><h2 id="Caching"><a class="docs-heading-anchor" href="#Caching">Caching</a><a id="Caching-1"></a><a class="docs-heading-anchor-permalink" href="#Caching" title="Permalink"></a></h2><p>StableHashTraits caches hash results for all types and large values. This cache is initialized per call to <code>stable_hash</code>; to leverage the same cache over multiple calls you can create a <a href="api/#StableHashTraits.CachedHash"><code>CachedHash</code></a>,</p><pre><code class="language-julia hljs">context = CachedHash(HashVersion{3}())
stable_hash(x, context)
stable_hash(y, context) # previously cached values will be re-used</code></pre><p>However, if you change or add any method definitions that are used to customize hashes (e.g. <a href="api/#StableHashTraits.transformer"><code>StableHashTraits.transformer</code></a>) you will need to create a new context to avoid using stale method results.</p><p>If you know that a particular object will be hashed repeatedly, you can make sure that it is cached by wrapping it in a <a href="api/#StableHashTraits.UseCache"><code>StableHashTraits.UseCache</code></a> object during a call to <a href="api/#StableHashTraits.transformer"><code>StableHashTraits.transformer</code></a>.</p><pre><code class="language-julia hljs">using StableHashTraits
using StableHashTraits: Transformer, UseCache

struct Foo
    x::Int
    ref::Bar
end

struct Bar
    data::Vector{Int}
end

foos = Foo.(rand(Int, 10_000), Ref(Bar(rand(Int, 1_000))))
# do not repeatedly hash `Bar`:
transformer(::Type{&lt;:Bar}) = Transformer(UseCache)</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Wednesday 1 May 2024 14:52">Wednesday 1 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
